
import { httpsCallable, Functions } from "firebase/functions";
import { functions, isFirebaseReady } from "./firebaseConfig";
import { GoogleGenAI, Type, FunctionDeclaration, Tool, FunctionCall } from "@google/genai";
import { AppState, Customer, AgentProfile, Contract, ProductStatus, PlanResult, Appointment, AppointmentStatus, AppointmentType, InteractionType, TimelineItem, IssuanceType } from "../types";
import { addData, updateData, COLLECTIONS } from "./db";

// Initialize Client-side AI (Fallback)
const getApiKey = (): string => {
    const envKey = process.env.API_KEY as string | undefined;
    if (envKey && typeof envKey === 'string' && envKey.length > 0) {
        return envKey;
    }
    return localStorage.getItem('gemini_api_key') || '';
};

const apiKey = getApiKey();
const clientAI = apiKey ? new GoogleGenAI({ apiKey }) : null;

let isServerAvailable = isFirebaseReady;

// MODEL CONFIG
const DEFAULT_MODEL = 'gemini-3-flash-preview'; 

// --- TOOL DEFINITIONS (FUNCTION CALLING) ---

const saveInteractionTool: FunctionDeclaration = {
    name: 'save_interaction',
    description: 'L∆∞u l·ªãch s·ª≠ t∆∞∆°ng t√°c, ghi ch√∫ ho·∫∑c k·∫øt qu·∫£ cu·ªôc g·ªçi v√†o h·ªì s∆° kh√°ch h√†ng.',
    parameters: {
        type: Type.OBJECT,
        properties: {
            customerId: { type: Type.STRING, description: 'ID c·ªßa kh√°ch h√†ng (l·∫•y t·ª´ d·ªØ li·ªáu ng·ªØ c·∫£nh).' },
            content: { type: Type.STRING, description: 'N·ªôi dung chi ti·∫øt c·ªßa t∆∞∆°ng t√°c ho·∫∑c ghi ch√∫.' },
            type: { type: Type.STRING, description: 'Lo·∫°i t∆∞∆°ng t√°c. V√≠ d·ª•: Ghi ch√∫, Cu·ªôc g·ªçi, G·∫∑p m·∫∑t, Chat Zalo.' },
            title: { type: Type.STRING, description: 'Ti√™u ƒë·ªÅ ng·∫Øn g·ªçn. V√≠ d·ª•: T∆∞ v·∫•n s·∫£n ph·∫©m A, Kh√°ch h·ªèi v·ªÅ quy·ªÅn l·ª£i...' }
        },
        required: ['customerId', 'content', 'type', 'title']
    }
};

const createAppointmentTool: FunctionDeclaration = {
    name: 'create_appointment',
    description: 'T·∫°o l·ªãch h·∫πn m·ªõi ho·∫∑c l·ªãch nh·∫Øc vi·ªác v·ªõi kh√°ch h√†ng.',
    parameters: {
        type: Type.OBJECT,
        properties: {
            customerId: { type: Type.STRING, description: 'ID c·ªßa kh√°ch h√†ng.' },
            customerName: { type: Type.STRING, description: 'T√™n kh√°ch h√†ng.' },
            date: { type: Type.STRING, description: 'Ng√†y h·∫πn ƒë·ªãnh d·∫°ng YYYY-MM-DD.' },
            time: { type: Type.STRING, description: 'Gi·ªù h·∫πn ƒë·ªãnh d·∫°ng HH:mm.' },
            type: { type: Type.STRING, description: 'Lo·∫°i l·ªãch h·∫πn: T∆∞ v·∫•n, G·ªçi chƒÉm s√≥c, Nh·∫Øc ph√≠, Ch√∫c m·ª´ng sinh nh·∫≠t, Kh√°c.' },
            note: { type: Type.STRING, description: 'Ghi ch√∫ cho l·ªãch h·∫πn.' }
        },
        required: ['customerId', 'date', 'type']
    }
};

const appTools: Tool[] = [{
    functionDeclarations: [saveInteractionTool, createAppointmentTool]
}];

// --- HELPER TO EXECUTE TOOLS ---
const executeTool = async (functionCall: FunctionCall, appState: AppState): Promise<any> => {
    const { name, args } = functionCall;
    console.log(`üõ†Ô∏è AI Executing Tool: ${name}`, args);

    try {
        if (name === 'save_interaction') {
            const { customerId, content, type, title } = args as any;
            const customer = appState.customers.find(c => c.id === customerId);
            if (!customer) return { result: "Error: Customer ID not found." };

            const newItem: TimelineItem = {
                id: Date.now().toString(),
                date: new Date().toISOString(),
                type: type as InteractionType || InteractionType.NOTE,
                title: title || 'Ghi ch√∫ t·ª´ AI',
                content: content,
                result: 'L∆∞u b·ªüi AI'
            };

            const updatedCustomer = {
                ...customer,
                timeline: [newItem, ...(customer.timeline || [])],
                interactionHistory: [`${new Date().toLocaleDateString()}: ${title} - ${content}`, ...(customer.interactionHistory || [])]
            };

            await updateData(COLLECTIONS.CUSTOMERS, customerId, updatedCustomer);
            return { result: "Success: ƒê√£ l∆∞u ghi ch√∫ v√†o h·ªì s∆° kh√°ch h√†ng." };
        }

        if (name === 'create_appointment') {
            const { customerId, customerName, date, time, type, note } = args as any;
            
            const newAppointment: Appointment = {
                id: '', // Generated by Firestore
                customerId,
                customerName: customerName || appState.customers.find(c => c.id === customerId)?.fullName || 'Kh√°ch h√†ng',
                date: date || new Date().toISOString().split('T')[0],
                time: time || '09:00',
                type: type as AppointmentType || AppointmentType.OTHER,
                status: AppointmentStatus.UPCOMING,
                note: note || 'ƒê·∫∑t b·ªüi AI'
            };

            await addData(COLLECTIONS.APPOINTMENTS, newAppointment);
            return { result: `Success: ƒê√£ t·∫°o l·ªãch h·∫πn th√†nh c√¥ng v√†o ng√†y ${date} l√∫c ${time}.` };
        }

        return { result: `Error: Tool ${name} not supported.` };
    } catch (error: any) {
        console.error("Tool Execution Failed:", error);
        return { result: `Error executing tool: ${error.message}` };
    }
};

// --- HELPER TO EXTRACT PDF TEXT ---
export const extractPdfText = async (url: string): Promise<string> => {
    if (!isServerAvailable || !functions) return "";
    try {
        const gateway = httpsCallable(functions as Functions, 'geminiGateway', { timeout: 300000 }); 
        const result: any = await gateway({
            endpoint: 'extractText',
            url: url
        });
        return result.data.text || "";
    } catch (e) {
        console.error("Failed to extract PDF text:", e);
        return "";
    }
};

// --- MAIN CALL FUNCTION ---
const callAI = async (payload: any): Promise<any> => {
    // 1. ∆Øu ti√™n d√πng Cloud Function (Server-side)
    if (isServerAvailable && functions) {
        try {
            const gateway = httpsCallable(functions as Functions, 'geminiGateway', { timeout: 300000 }); 
            const result: any = await gateway(payload);
            return result.data; // Returns { text, functionCalls, ... }
        } catch (serverError: any) {
            console.warn("‚ö†Ô∏è Server Backend failed or returned error.", serverError);
            isServerAvailable = false; 
        }
    }

    // 2. Fallback xu·ªëng Client-side (Direct API)
    try {
        if (!clientAI) throw new Error("Missing API Key");
        
        const { cachedContent, tools, ...clientPayload } = payload;
        
        const modelId = (clientPayload.model as string) || DEFAULT_MODEL; 
        const config = clientPayload.config || {};
        if (clientPayload.systemInstruction) config.systemInstruction = clientPayload.systemInstruction;
        
        // Pass tools if enabled
        if (tools) config.tools = tools;

        if (clientPayload.endpoint === 'chat') {
            const chat = clientAI.chats.create({
                model: modelId,
                config: config,
                history: clientPayload.history || []
            });
            
            // Handle Message Content (String or Parts)
            const msg = clientPayload.message; 
            const result = await chat.sendMessage({ message: msg });
            
            return {
                text: result.text,
                functionCalls: result.functionCalls
            };
        } else {
            const result = await clientAI.models.generateContent({
                model: modelId,
                contents: clientPayload.contents,
                config: config
            });
            return {
                text: result.text,
                functionCalls: result.functionCalls
            };
        }
    } catch (clientError: any) {
        console.error("‚ùå Client AI Error:", clientError);
        if (clientError.message.includes("404")) {
             return { text: "L·ªói c·∫•u h√¨nh AI (404): Model kh√¥ng t·ªìn t·∫°i ho·∫∑c API Key kh√¥ng h·ª£p l·ªá." };
        }
        return { text: `L·ªói AI: ${clientError.message}` };
    }
};

// Helper: Remove Vietnamese accents for better matching
const removeAccents = (str: string) => {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/ƒë/g, "d").replace(/ƒê/g, "D");
};

// --- INTELLIGENT CONTEXT BUILDER ---
const findRelevantContext = (query: string, state: AppState): string => {
    const lowerQuery = query.toLowerCase();
    const noAccentQuery = removeAccents(lowerQuery);
    let context = "";
    
    // --- 1. GLOBAL ROSTER (DANH S√ÅCH KH√ÅCH H√ÄNG HI·ªÜN C√ì) ---
    // Lu√¥n cung c·∫•p danh s√°ch t√™n ƒë·ªÉ AI bi·∫øt ai l√† ng∆∞·ªùi th·∫≠t
    const roster = state.customers.map(c => `- ${c.fullName} (ID: ${c.id})`).join('\n');
    context += `\n=== DANH S√ÅCH KH√ÅCH H√ÄNG TH·∫¨T TRONG H·ªÜ TH·ªêNG ===\n(Ch·ªâ tr·∫£ l·ªùi v√† th·ª±c hi·ªán h√†nh ƒë·ªông v·ªõi ID c√≥ trong danh s√°ch n√†y)\n${roster}\n==============================================\n`;

    // --- 2. DETECT CUSTOMERS BY NAME / PHONE (DEEP SEARCH) ---
    const matchedCustomers = state.customers.filter(c => {
        const fullName = c.fullName.toLowerCase();
        const noAccentName = removeAccents(fullName);
        const phone = c.phone.replace(/\D/g, ''); 
        
        if (fullName.includes(lowerQuery) || noAccentName.includes(noAccentQuery)) return true;
        if (phone.includes(query) || (query.length >= 4 && phone.endsWith(query))) return true;
        
        const names = fullName.split(' ');
        const firstName = names[names.length - 1];
        if (lowerQuery.length > 2 && lowerQuery.includes(firstName)) return true;
        
        return false;
    });

    if (matchedCustomers.length > 1) {
        context += `\n‚ö†Ô∏è C·∫¢NH B√ÅO NH·∫¨P NH·∫∞NG: T√¨m th·∫•y ${matchedCustomers.length} kh√°ch h√†ng kh·ªõp t√™n.\n`;
        matchedCustomers.forEach(c => {
            context += `- ${c.fullName} (ID: ${c.id}, SƒêT: ${c.phone})\n`;
        });
    }

    if (matchedCustomers.length > 0) {
        matchedCustomers.forEach(c => {
            context += `\n--- CHI TI·∫æT D·ªÆ LI·ªÜU C·ª¶A KH√ÅCH H√ÄNG: ${c.fullName} (ID: ${c.id}) ---\n`;
            context += `   - ID: ${c.id}\n`;
            context += `   - NƒÉm sinh: ${new Date(c.dob).getFullYear()}, Gi·ªõi t√≠nh: ${c.gender}\n`;
            context += `   - SƒêT: ${c.phone}\n`;
            
            // Add Contracts with WARNINGS for Exclusions
            const customerContracts = state.contracts.filter(ct => ct.customerId === c.id);
            if (customerContracts.length > 0) {
                context += `   - Danh s√°ch H·ª£p ƒë·ªìng:\n`;
                customerContracts.forEach(ct => {
                    let warning = "";
                    if (ct.issuanceType === IssuanceType.CONDITIONAL) {
                        warning = `[‚ö†Ô∏è C·∫¢NH B√ÅO: Hƒê n√†y C√ì ƒêI·ªÄU KI·ªÜN. Lo·∫°i tr·ª´: "${ct.exclusionNote || 'Kh√¥ng r√µ'}". TƒÉng ph√≠: ${ct.loadingFee || 0}ƒë]`;
                    }
                    context += `     + S·ªë Hƒê: ${ct.contractNumber} (${ct.status}) - ${ct.mainProduct.productName}. ${warning}\n`;
                });
            }

            if (c.timeline && c.timeline.length > 0) {
                const sortedTimeline = [...c.timeline].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime());
                context += `   - L·ªãch s·ª≠ t∆∞∆°ng t√°c g·∫ßn nh·∫•t:\n`;
                sortedTimeline.slice(0, 5).forEach(t => { 
                    context += `     + [${t.date.split('T')[0]}] ${t.title}: ${t.content}\n`;
                });
            }
            context += `--------------------------------------------------\n`;
        });
    }

    return context;
};

const sanitizeHistory = (history: any[]) => {
    const firstUserIndex = history.findIndex(h => h.role === 'user');
    if (firstUserIndex === -1) return [];
    const validHistory = history.slice(firstUserIndex);
    return validHistory.map(h => ({
        role: h.role,
        parts: h.parts || [{ text: h.text }]
    }));
};

// --- CHAT WITH DATA (RAG + TOOLS) ---
export const chatWithData = async (
  query: string, 
  appState: AppState, 
  history: { role: 'user' | 'model'; text: string }[]
): Promise<string> => {
    
    // 1. Context
    const activeProducts = appState.products.filter(p => p.status === ProductStatus.ACTIVE);
    let knowledgeBase = "";
    activeProducts.forEach(p => {
        if (p.extractedContent) knowledgeBase += `\n--- T√ÄI LI·ªÜU S·∫¢N PH·∫®M: ${p.name} ---\n${p.extractedContent.substring(0, 15000)}...\n`; 
    });
    const specificContext = findRelevantContext(query, appState);

    // 2. System Prompt
    const systemInstructionText = `B·∫°n l√† TuanChom AI, Tr·ª£ l√Ω Nghi·ªáp v·ª• B·∫£o hi·ªÉm Prudential chuy√™n nghi·ªáp.
    
    QUY·ªÄN H·∫†N & C√îNG C·ª§:
    - B·∫°n c√≥ quy·ªÅn TRUY C·∫¨P d·ªØ li·ªáu kh√°ch h√†ng (xem context b√™n d∆∞·ªõi).
    - B·∫°n c√≥ quy·ªÅn GHI L·∫†I (L∆∞u) t∆∞∆°ng t√°c v√† T·∫†O L·ªäCH H·∫∏N b·∫±ng c√°ch g·ªçi h√†m (function calling).
    - N·∫øu ng∆∞·ªùi d√πng y√™u c·∫ßu "L∆∞u l·∫°i", "Ghi ch√∫ l·∫°i", "T·∫°o l·ªãch h·∫πn", "Nh·∫Øc t√¥i...", H√ÉY G·ªåI H√ÄM T∆Ø∆†NG·ª®NG ngay l·∫≠p t·ª©c. ƒê·ª´ng ch·ªâ n√≥i su√¥ng.
    
    QUY T·∫ÆC QUAN TR·ªåNG V·ªÄ LO·∫†I TR·ª™ (EXCLUSIONS):
    - Khi tr·∫£ l·ªùi v·ªÅ quy·ªÅn l·ª£i chi tr·∫£ (Claim), B·∫ÆT BU·ªòC ph·∫£i ki·ªÉm tra xem H·ª£p ƒë·ªìng c√≥ ghi ch√∫ [C·∫¢NH B√ÅO: Hƒê n√†y C√ì ƒêI·ªÄU KI·ªÜN] kh√¥ng.
    - N·∫øu c√≥ Lo·∫°i tr·ª´, b·∫°n PH·∫¢I c·∫£nh b√°o ng∆∞·ªùi d√πng r·∫±ng b·ªánh/r·ªßi ro n√†y c√≥ th·ªÉ kh√¥ng ƒë∆∞·ª£c chi tr·∫£ do ƒëi·ªÅu kho·∫£n lo·∫°i tr·ª´.
    
    D·ªÆ LI·ªÜU KH√ÅCH H√ÄNG & B·ªêI C·∫¢NH:
    ${specificContext}
    
    KI·∫æN TH·ª®C S·∫¢N PH·∫®M:
    ${knowledgeBase}
    
    H∆Ø·ªöNG D·∫™N:
    1. Tra c·ª©u th√¥ng tin ƒë·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi.
    2. N·∫øu c·∫ßn l∆∞u th√¥ng tin, h√£y g·ªçi 'save_interaction'.
    3. N·∫øu c·∫ßn ƒë·∫∑t l·ªãch, h√£y g·ªçi 'create_appointment'.
    4. Tr·∫£ l·ªùi ng·∫Øn g·ªçn, chuy√™n nghi·ªáp.
    `;

    const cleanHistory = sanitizeHistory(history);

    try {
        // STEP 1: First Call to AI (Text or Function Call Request)
        const response = await callAI({
            endpoint: 'chat',
            model: DEFAULT_MODEL, 
            message: query,
            history: cleanHistory,
            systemInstruction: systemInstructionText, 
            tools: appTools, // Enable Tools
            config: { temperature: 0.1 } 
        });

        // STEP 2: Check for Tool Calls
        if (response.functionCalls && response.functionCalls.length > 0) {
            // Execute all requested tools
            const toolResults = [];
            for (const fc of response.functionCalls) {
                const output = await executeTool(fc, appState);
                toolResults.push({
                    functionResponse: {
                        name: fc.name,
                        response: output
                    }
                });
            }

            // STEP 3: Send Tool Results back to AI to get final confirmation text
            // Note: In Cloud Functions or simple chat API, we often just make a fresh call with the result info 
            // or construct a proper multi-turn history. For simplicity here, we append tool result to history and ask for summary.
            
            const toolOutputText = JSON.stringify(toolResults);
            
            // Construct a follow-up message pretending to be the system providing tool outputs
            // Since `chats.create` maintains history in the session instance on client, 
            // but here we might be stateless if using Cloud Functions.
            // We will do a recursive call or a second call with updated history.
            
            const secondTurnResponse = await callAI({
                endpoint: 'chat',
                model: DEFAULT_MODEL,
                // Append the tool execution result as a "User" or "System" message for context
                message: `[System]: Tool execution results: ${toolOutputText}. H√£y x√°c nh·∫≠n l·∫°i v·ªõi ng∆∞·ªùi d√πng b·∫±ng ti·∫øng Vi·ªát.`,
                history: [
                    ...cleanHistory, 
                    { role: 'user', parts: [{ text: query }] }, 
                    { role: 'model', parts: [{ functionCall: response.functionCalls[0] }] } // Simplified history
                ],
                systemInstruction: systemInstructionText,
                config: { temperature: 0.1 }
            });

            return secondTurnResponse.text || "ƒê√£ th·ª±c hi·ªán y√™u c·∫ßu.";
        }

        return response.text || "Xin l·ªói, t√¥i kh√¥ng hi·ªÉu √Ω b·∫°n.";

    } catch (error: any) {
        console.error("Chat Error:", error);
        return "Xin l·ªói, h·ªá th·ªëng ƒëang g·∫∑p s·ª± c·ªë k·∫øt n·ªëi.";
    }
};

// ... (Rest of existing functions like consultantChat, etc. remain unchanged) ...
export const consultantChat = async (
    query: string, customer: Customer, contracts: Contract[], familyContext: any[],
    agentProfile: AgentProfile | null, conversationGoal: string,
    history: { role: 'user' | 'model'; text: string }[],
    roleplayMode: 'consultant' | 'customer' = 'consultant',
    planResult: PlanResult | null = null,
    chatStyle: 'zalo' | 'formal' = 'formal'
): Promise<string> => {
    
    let agentContext = "T√™n b·∫°n: T∆∞ v·∫•n vi√™n Prudential.";
    if (agentProfile) {
        agentContext = `
        TH√îNG TIN C·ª¶A B·∫†N (T∆Ø V·∫§N VI√äN):
        - H·ªç t√™n: ${agentProfile.fullName}
        - Danh hi·ªáu: ${agentProfile.title}
        - ƒê∆°n v·ªã: ${agentProfile.office || "Prudential Vietnam"}
        `;
    }

    const customerContext = `
    TH√îNG TIN KH√ÅCH H√ÄNG:
    - H·ªç t√™n: ${customer.fullName}
    - Tu·ªïi: ${new Date().getFullYear() - new Date(customer.dob).getFullYear()}
    - Ngh·ªÅ nghi·ªáp: ${customer.job}
    - T√¨nh tr·∫°ng: ${customer.status}
    - M·ªëi quan t√¢m: ${customer.analysis?.keyConcerns || 'Ch∆∞a r√µ'}
    - T√≠nh c√°ch (DISC): ${customer.analysis?.personality || 'Ch∆∞a r√µ'}
    `;

    const contractInfo = contracts.length > 0 
        ? contracts.map(c => {
            let info = `- Hƒê ${c.contractNumber}: ${c.mainProduct.productName} (${c.status}). Ph√≠: ${c.totalFee.toLocaleString()}ƒë`;
            if (c.issuanceType === IssuanceType.CONDITIONAL) {
                info += `\n  ‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG: Hƒê n√†y C√ì ƒêI·ªÄU KI·ªÜN. Lo·∫°i tr·ª´: "${c.exclusionNote}". TƒÉng ph√≠: ${c.loadingFee}ƒë.`;
            }
            return info;
        }).join('\n') 
        : "Ch∆∞a c√≥ h·ª£p ƒë·ªìng n√†o.";
    
    const familyInfo = familyContext.length > 0
        ? familyContext.map(f => `- ${f.relationship}: ${f.name || 'Ng∆∞·ªùi th√¢n'} `).join('\n')
        : "Ch∆∞a c√≥ th√¥ng tin gia ƒë√¨nh.";

    let planContext = "";
    if (planResult) {
        planContext = `
        D·ªÆ LI·ªÜU T√ÄI CH√çNH TH·ª∞C T·∫æ:
        - M·ª•c ti√™u: ${planResult.goal}
        - Thi·∫øu h·ª•t (Gap): ${planResult.shortfall.toLocaleString()}ƒë
        `;
    }

    const systemInstruction = `
    B·ªêI C·∫¢NH: B·∫°n ƒëang tham gia Roleplay (M√¥ ph·ªèng t∆∞ v·∫•n).
    VAI TR√í C·ª¶A B·∫†N: ${roleplayMode === 'consultant' ? 'T∆Ø V·∫§N VI√äN CHU·∫®N MDRT' : 'KH√ÅCH H√ÄNG'}.
    ${roleplayMode === 'consultant' ? agentContext : ''}
    ${customerContext}
    TH√îNG TIN B·ªî SUNG:
    - H·ª£p ƒë·ªìng hi·ªán t·∫°i (Ch√∫ √Ω c√°c ƒëi·ªÅu kho·∫£n lo·∫°i tr·ª´ n·∫øu c√≥): 
    ${contractInfo}
    - Gia ƒë√¨nh: ${familyInfo}
    ${planContext}
    M·ª§C TI√äU: ${conversationGoal}
    PHONG C√ÅCH: ${chatStyle === 'zalo' ? 'Th√¢n m·∫≠t, ng·∫Øn g·ªçn (Zalo)' : 'Chuy√™n nghi·ªáp (Email/G·∫∑p)'}.
    
    ${roleplayMode === 'consultant' ? `
    QUY T·∫ÆC MDRT:
    1. Kh√¥ng b√°n h√†ng g∆∞·ª£ng √©p.
    2. D·∫´n d·∫Øt b·∫±ng c√¢u h·ªèi.
    3. T·∫≠p trung v√†o "T·∫°i sao" (Why).
    4. ƒê·ªìng c·∫£m tr∆∞·ªõc khi gi·∫£i quy·∫øt t·ª´ ch·ªëi.
    ` : `
    H∆Ø·ªöNG D·∫™N KH√ÅCH H√ÄNG:
    1. ƒê√≥ng vai Kh√°ch h√†ng ${customer.fullName}.
    2. Ph·∫£n ·ª©ng d·ª±a tr√™n t√≠nh c√°ch: ${customer.analysis?.personality}.
    `}
    `;

    const cleanHistory = sanitizeHistory(history);

    try {
        const result = await callAI({
            endpoint: 'chat',
            model: DEFAULT_MODEL,
            message: query,
            history: cleanHistory,
            systemInstruction: systemInstruction,
            config: { temperature: 0.7 }
        });
        return result.text;
    } catch (e) {
        return "L·ªói k·∫øt n·ªëi AI.";
    }
};

export const getObjectionSuggestions = async (msg: string, customer: Customer): Promise<any[]> => {
    const result = await callAI({
        endpoint: 'generateContent',
        model: DEFAULT_MODEL,
        contents: `Kh√°ch h√†ng v·ª´a n√≥i: "${msg}". ƒê√≥ng vai Coach MDRT, g·ª£i √Ω 3 c√°ch x·ª≠ l√Ω t·ª´ ch·ªëi (ƒê·ªìng c·∫£m, H·ªèi ng∆∞·ª£c, K·ªÉ chuy·ªán).`,
        config: { 
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        label: { type: Type.STRING },
                        type: { type: Type.STRING },
                        content: { type: Type.STRING }
                    },
                    required: ["label", "type", "content"]
                }
            }
        }
    });
    try { return JSON.parse(result.text); } catch { return []; }
};

export const generateSocialPost = async (topic: string, tone: string): Promise<any[]> => {
    const result = await callAI({
        endpoint: 'generateContent',
        model: DEFAULT_MODEL,
        contents: `Topic: ${topic}. Tone: ${tone}. Vi·∫øt 3 status FB. Output JSON array {title, content}.`,
        config: { responseMimeType: "application/json" }
    });
    try { return JSON.parse(result.text); } catch { return []; }
};

export const generateContentSeries = async (topic: string): Promise<any[]> => {
    const result = await callAI({
        endpoint: 'generateContent',
        model: DEFAULT_MODEL,
        contents: `Topic: ${topic}. Plan 5 days content series. Output JSON array {day, type, content}.`,
        config: { responseMimeType: "application/json" }
    });
    try { return JSON.parse(result.text); } catch { return []; }
};

export const generateStory = async (facts: string, emotion: string): Promise<string> => {
    const result = await callAI({
        endpoint: 'generateContent',
        model: DEFAULT_MODEL,
        contents: `Facts: ${facts}. Emotion: ${emotion}. Write a touching story.`,
        config: { temperature: 0.9 }
    });
    return result.text;
};

export const generateFinancialAdvice = async (customerName: string, planResult: PlanResult): Promise<string> => {
    const prompt = `B·∫°n l√† Chuy√™n gia T√†i ch√≠nh Prudential. Nh·∫≠n x√©t ng·∫Øn v·ªÅ KH ${customerName}. M·ª•c ti√™u: ${planResult.goal}. Gap: ${planResult.shortfall.toLocaleString()}ƒë. L·ªùi khuy√™n 3 c√¢u.`;
    const result = await callAI({ endpoint: 'generateContent', model: DEFAULT_MODEL, contents: prompt });
    return result.text;
};

export const generateClaimSupport = async (contract: Contract, customer: Customer): Promise<string> => {
    const result = await callAI({
        endpoint: 'generateContent',
        model: DEFAULT_MODEL,
        contents: `So·∫°n tin h∆∞·ªõng d·∫´n Claim Hƒê ${contract.contractNumber} cho ${customer.fullName}`
    });
    return result.text;
};
